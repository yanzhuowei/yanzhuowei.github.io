---
title: 浏览器渲染原理
date: 2020-10-30 15:58:09
author: 慕言
img: 
top: true
summary: 从用户在浏览器地址输入网址到看到页面，中间发生了什么?
categories: 浏览器
tags:
  - 浏览器渲染原理
---
从一道面试题引起：用户在浏览器地址输入网址到看到页面中间经历了什么？

![](/img/liulanqi/1.png)
其实中间主要经历了3个阶段：1、HTTP请求阶段 2、HTTP响应阶段 3、浏览器渲染阶段

#### 进程(Process)和线程(Thread)

**进程：** **是具有一定独立功能的程序、它是系统进行资源分配和调度的一个独立单位，重点在系统调度和单独的单位，也就是说**进程是可以独立运行的一段程序**。

**线程：** **是进程的一个实体，是CPU调度和分派的基本单位（CPU上真正运行的是线程），程序执行的路径。**。线程自己基本上不拥有系统资源。在运行时，只是暂用一些计数器、寄存器和栈 。

**线程间内存共享：**一个进程的内存空间是共享的，每个线程都可以使用这个共享内存。

**单核CPU执行多任务：**操作系统轮流让各个任务交替执行。例如：任务1执行0.01秒，切换到任务2执行0.01秒，在切换到任务3......由于CPU执行速度过快，我们感知不到感觉像是在同时执行其实不是。

**多核CPU执行多任务：**真正的并行执行多个任务，但是如果任务数量远远多于CPU核心数量，那么操作系统也会自动把多个任务轮流调度到每个核心上执行。

**多线程可以同时执行：**多线程的执行方式和多进程一样，也是由操作系统在多个线程之间快速切换，让每个线程短暂交替运行。

#### HTTP请求阶段

##### 一、URL解析阶段

**URI**：统一资源标识符 （包含URL和URN）；**URL**：统一资源定位符；**URN**：统一资源名称；

**一个完成URL的组成部分和实际意义**（例：https://www.baidu.com:443/index.html）

- 协议：传输协议（http：超文本传输协议，传输文本、二进制码、文件流...；https；ftp:资源上传协议，一般应用于吧本地文件直接上传到服务器端）

- 域名

- 端口号（根据端口号，找到当前服务器上的指定服务；0-65535；不同协议有自己默认端口：http--》80、https--》443、ftp--》21）

- 请求资源和路径名称（/stu/index.html ：一般情况，我们访问的是inde.html是可以省略不写的）

- ？号传参部分 (?xxx=xxx)

  如遇需要进行编码处理方法：

  1、encodeURL / decodeURL (只能把中文和空格编译成编码,一般用来把整个url进行编码)

  2、encodeURLComponent / decodeURLComponent (所有特殊字符都会进行编码，一般不会用来处理整个url,只给传递的参数值进行特殊处理)
  以上两种客户端和服务器端都支持

  3、escape / unescape (这种方式不一定所有服务器端都支持)

  ...

- 哈希 (#xxx)

  > **伪URL**
  >
  > 什么地方会使用伪url？
  >
  > 1、SEO优化
  >
  > 2、数据请求的接口地址
  >
  > 动态页面地址：真实地址
  >
  > https://item.jd.com/detail.php?id=22298647726
  >
  > 需要把上面的地址重写为下面的静态地址需要用到：**URL伪重写技术**
  >
  > https://item.jd.com/22298647726.html
  >

##### 二、DNS域名解析

DNS域名解析是什么？

通过域名找到对应的服务器外网IP；

网站，每发送一个TCP请求，都要进行DNS解析（一旦解析过一次，浏览器一般会缓存解析记录，缓存时间一般在1分钟左右）

DNS解析时访问服务器的顺序：
![](/img/liulanqi/2.png)

优化手段：DNS预获取
![](/img/liulanqi/3.png)

##### 三、建立TCP连接（三次握手）

基于TCP的三次握手，能够建立客户端和服务器的连接通道，只有建立好通道，才能基于HTTP等传输协议，实现客户端和服务器端的信息交互
![](/img/liulanqi/4.png)

##### 四、发送HTTP请求

基于HTTP等传输协议，客户端把一些信息传输给服务器

- HTTP请求报文（所有客户端传输给服务器的内容，统称请求报文）

  包含：请求起始行、请求头、请求主体

- 强缓存 和 协商缓存 （主要作用是性能优化，减少http请求次数）具体详解，看性能优化文章

#### HTTP响应阶段

##### 一、服务器接收请求，并进行处理，最后把信息返回给客户端

- HTTP响应报文 （服务器返回给客户端的内容）
  包含：响应起始行、响应头、响应主体

##### 二、断开TCP连接通道（四次挥手）

** 当客户端把请求放给服务器后，就挥第一次手**
![](/img/liulanqi/5.png)

优化点：服务端设置 Connection:Keep-Alive 保持TCP不中断

#### 浏览器渲染阶段

浏览器是多线程的，页面渲染是单线的；

##### 一、拿到index.html后浏览器会开辟一块栈内存，同时分配一个主线程“自上而下，自左而右”的去解析执行；

##### 二、在解析执行DOM结构时遇到**link**、**img**、**video**...浏览器会开启一个全新线程去加载资源，但不会执行。主线程继续向下执行；
  - 遇到 **style** 内嵌样式正常解析执行
  - @import 导入样式 （同步）不会开辟新线程去加载资源，而是主线程去获取资源并加载完毕才会继续向下继续解析执行DOM 

##### 三、遇到**script**、外链js会去获取资源并**执行**，会阻塞DOM生成；优化：使用**defer**、**async**去异步获取资源，等dom渲染完执行；
  - 现代浏览器都有完善的代码扫描机制，如果遇到script需要同步加载执行时，同时会向下扫描代码，如果发现有一些异步获取资源代码，此时就开始请求资源了
  - 自我等待机制：因为在JS中可能会有操作元素样式的情况出现，所以哪怕异步请求的js资源加载完成了，执行js代码也会等到css加载并渲染完成后才会执行
  - defer 异步获取资源后，按照顺序去执行
  - async 异步获取资源后，执行是无序的，谁先加载回来谁先执行
  - DOMContentLoaded() : 当DOM结构加载完成就会触发
  - $(function(){})||$(doucment).ready(function(){})
  - load() : 所有资源加载完成才会执行，包含图片等资源加载

##### 四、自上而下执行完毕后，会生成**DOM Tree**

##### 五、主线程现在可以去执行加载回来的css资源了，执行完css会生成**CSSOM**

##### 六、将**DOM Tree**和**CSSOM**结合生成**Render Tree**(渲染树)

##### 六、浏览器通知GPU(显卡)开始按照Render Tree绘制图形到页面中
![](/img/liulanqi/6.png)

#### DOM的重绘和回流

**重绘**：元素样式的改变（但宽高、大小、位置等不变）

**回流**：元素的大小或者位置发生了变化，触发重新布局导致渲染树重新计算布局和渲染

**重绘不一定回流，回流一定触发重绘**









