<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>作用域、作用域链、闭包</title>
      <link href="2020/11/21/zuo-yong-yu-zuo-yong-yu-lian-bi-bao/"/>
      <url>2020/11/21/zuo-yong-yu-zuo-yong-yu-lian-bi-bao/</url>
      
        <content type="html"><![CDATA[<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><blockquote><p>函数就是一个方法或者一个功能体，就是把实现某个功能的代码放到一起进行封装;封装：减少页面中的冗余代码，提高代码重复使用率（低耦合高内聚）；</p></blockquote><ul><li>函数分为声明函数和函数执行<ul><li>声明函数：函数存储在堆中，堆中存储的是函数体代码字符串和键值对（例如：arguments:null,length:0 ,name: “fn”…等等；<strong>初始化作用域（创建函数时当前执行上下文存储变量的地方）</strong></li><li>函数执行：1、查找调用函数的代码，开辟一块 <strong>全新的栈内存（函数内部的变量不能被外部访问，只能return出去）</strong> ，建立函数上下文，进栈执行；2、初始化this指向 3、初始化作用域链 4、创建变量对象VO (1、arguments对象 2、创建形参变量并赋值 3、有变量提升话变量提升    ) 5、代码执行</li></ul></li></ul><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><blockquote><p>作用域也就是<strong>创建函数时</strong>当前执行上下文存储变量的地方 <strong>（VO/AO）</strong></p></blockquote><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><blockquote><p>变量取值的过程，先在自己执行上下文中的变量对象中找看是否是自己AO中的私有变量，找不到就去上级作用域查找，有则停止，无就继续，一直找到全局作用域。</p></blockquote><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><blockquote><p><strong>函数执行形成一个全新的执行上下文，进栈执行后所创建的一些变量被外部所引用，不能出栈销毁，就形成了闭包。</strong><br>作用：延长了局部变量的生命周期，保护全不被污染<br>缺点：函数不能被出栈销毁，频繁使用会造成内存泄漏问题。<br>解决方法：手动销毁 fn=null</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 作用域、闭包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆栈底层机制</title>
      <link href="2020/11/20/dui-zhan-di-ceng-ji-zhi/"/>
      <url>2020/11/20/dui-zhan-di-ceng-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p><strong>ECStack</strong>：Execution [ˌeksɪˈkjuːʃn] Context Stack 执行上下文环境栈</p><p><strong>EC</strong>：Execution Context 执行环境（执行上下文）当前js代码被解析和执行时所在环境 有全局执行上线文和函数执行上下文</p><p><strong>GO</strong>: global Object 全局对象，进入任何执行上下文之前就已经创建了的对象； 这个对象只存在一份，它的属性在程序中任何地方都可以访问，全局对象的生命周期终止于程序退出那一刻。<br>        1、在浏览器端会把全局对象赋值给window，所以window就是全局对象，node中不是这样，global全局对象存储一些全局共享的数据。<br>        2、在全局执行上下文中用var声明一个变量，也会给全局对象GO中（window）增加一个对应的属性；但是用let声明的变量不存在这个特点,不会给全局对象（window）中增加对应属性</p><p><strong>VO</strong>：Varibale Object 变量对象(一个与执行上下文相关的特殊对象，存储了在上下文中定义的变量和函数声明)</p><p><strong>AO</strong>：Activation Object 活动对象 （在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象,变量对象和活动对象其实是一个东西，只有当函数执行当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object）</p><p><strong>Scope</strong>：作用域，创建的函数的时候就赋予的</p><p><strong>Scope Chain</strong> ：作用域链</p><pre class=" language-js"><code class="language-js">抽象变量对象VO <span class="token punctuation">(</span>变量初始化过程的一般行为<span class="token punctuation">)</span>  ║  ╠══<span class="token operator">></span> 全局上下文变量对象GlobalContextVO  ║        <span class="token punctuation">(</span>VO <span class="token operator">===</span> <span class="token keyword">this</span> <span class="token operator">===</span> global<span class="token punctuation">)</span>  ║  ╚══<span class="token operator">></span> 函数上下文变量对象FunctionContextVO           <span class="token punctuation">(</span>VO <span class="token operator">===</span> AO<span class="token punctuation">,</span> 并且添加了<span class="token operator">&lt;</span>arguments<span class="token operator">></span>和<span class="token operator">&lt;</span>formal parameters<span class="token operator">></span><span class="token punctuation">)</span></code></pre><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><pre class=" language-js"><code class="language-js">编译器 （把代码解析成浏览器看的懂的结构）  ║  ╠══<span class="token operator">></span> 词法解析  ╠══<span class="token operator">></span> AST抽象语法树  ╠══<span class="token operator">></span> 构建出浏览器能够执行的代码  ║JS引擎（v8 <span class="token operator">/</span> webkit内核） （调用引擎执行代码）     ║  ╠══<span class="token operator">></span> 创建栈内存（ECStack<span class="token punctuation">:</span>执行上下文环境栈，用来执行代码）  ╠══<span class="token operator">></span> 创建全局对象 GO 唯一的，它的属性在程序中任何地方都可以访问，全局对象的生命周期终止于程序退出那一刻  ╠══<span class="token operator">></span> 形成全局执行上下文 （创建VO：存储了在上下文中定义的变量和函数声明）  ╠══<span class="token operator">></span> 把全局执行上下文压缩到栈中执行<span class="token operator">--</span>进栈  ║  ╠══<span class="token operator">></span> 代码执行<span class="token operator">...</span><span class="token punctuation">.</span>  ║                   ╠══<span class="token operator">></span> 变量赋值 ════ <span class="token number">1</span>、声明变量 <span class="token number">2</span>、创建值（分为基础数据类型（栈中存储）和引用数据类型（堆中存储））<span class="token number">3</span>、赋值（变量和值关联）        <span class="token operator">-</span> 由于引用类型是复杂的结构，所以特殊处理<span class="token operator">--</span><span class="token operator">></span> <span class="token operator">**</span> 开辟一个存储对象键值对<span class="token operator">||</span>函数体代码字符串的内存空间<span class="token operator">**</span> <span class="token operator">**</span>堆内存<span class="token operator">**</span> 有一个可被查找的<span class="token number">16</span>进制地址 在赋值操作时会把地址给予变量  ║  ╠══<span class="token operator">></span> 函数声明赋值 ════ 函数和<span class="token keyword">let</span>、<span class="token keyword">var</span>创建的变量本质一样，只是存储的值是个Function类型的值 <span class="token number">1</span>、声明变量 <span class="token number">2</span>、创建值 （函数类型，存储在堆中。存储的的是函数体代码字符串和键值对形式 例如：键值对有 arguments<span class="token punctuation">:</span><span class="token keyword">null</span><span class="token punctuation">,</span>length<span class="token punctuation">:</span><span class="token number">0</span> <span class="token punctuation">,</span>name<span class="token punctuation">:</span> <span class="token string">"fn"</span><span class="token punctuation">,</span>__proto__<span class="token punctuation">:</span> ƒ <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">...</span>等等）<span class="token number">3</span>、赋值（变量和值关联） <span class="token number">4</span>、初始化当前函数的作用域（创建函数时当前执行上下文存储变量的地方）注意：在非严格模式下，形参、实参、arguments对象会建立一种映射机制，改变其中一个会影响其他。严格模式下不会。  ║  ╠══<span class="token operator">></span> 代码执行<span class="token operator">...</span><span class="token punctuation">.</span>  ║  ╠══<span class="token operator">></span> 函数执行 ════ 查找调用函数的代码，开辟一块全新的栈内存，建立函数上下文，进栈执行；初始化<span class="token keyword">this</span>指向、初始化作用域链、创建变量对象VO <span class="token punctuation">(</span><span class="token operator">-</span>创建arguments对象 <span class="token operator">-</span>创建形参变量并赋值 <span class="token operator">-</span>有变量提升话变量提升    <span class="token punctuation">)</span>、代码执行  ║  ╠══<span class="token operator">></span> 函数执行完毕并且和全局执行上下文没有关系，出栈（函数销毁），然后全局执行上下文执行（有关系不出栈，压缩到栈底，把全局上线文拿上来执行）  ║  ╚══<span class="token operator">></span> 代码执行完毕，程序退出栈内存销毁</code></pre><p><img src="/img/duizhan/2.png"><br><img src="/img/duizhan/1.png"></p><h3 id="画图演示"><a href="#画图演示" class="headerlink" title="画图演示"></a>画图演示</h3><p><img src="/img/duizhan/3.png"></p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> a<span class="token operator">=</span><span class="token punctuation">{</span>n<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token keyword">let</span> b<span class="token operator">=</span>a<span class="token punctuation">;</span>a<span class="token punctuation">.</span>x<span class="token operator">=</span>a<span class="token operator">=</span><span class="token punctuation">{</span>n<span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>x<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>a<span class="token punctuation">.</span>x<span class="token operator">=</span>a<span class="token operator">=</span><span class="token punctuation">{</span>n<span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">}</span>就相当于 a<span class="token punctuation">.</span>x<span class="token operator">=</span><span class="token punctuation">{</span>n<span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">}</span> a<span class="token operator">=</span><span class="token punctuation">{</span>n<span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">}</span></code></pre><p><img src="/img/duizhan/4.png"></p><p><img src="/img/duizhan/5.png"></p><p><img src="/img/duizhan/6.png"></p><p><img src="/img/duizhan/7.png"></p><p><img src="/img/duizhan/8.png"></p><p><img src="/img/duizhan/9.png"></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆栈存储机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中的数据类型</title>
      <link href="2020/11/12/javascript-zhong-de-shu-ju-lei-xing/"/>
      <url>2020/11/12/javascript-zhong-de-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<h3 id="JavaScript中的数据类型"><a href="#JavaScript中的数据类型" class="headerlink" title="JavaScript中的数据类型"></a>JavaScript中的数据类型</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>基本数据类型：Number、String、Boolean、null、undefined、Symbol</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>应用数据类型：Object （{}、[]、/^s/……）、function</strong></p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><blockquote><p>所有用单引号、双引号、反引号（ ES6模板字符串）包起来的都是字符串</p></blockquote><h5 id="把其他类型值转换成字符串"><a href="#把其他类型值转换成字符串" class="headerlink" title="把其他类型值转换成字符串"></a>把其他类型值转换成字符串</h5><p><strong>toString()：</strong> null、undefined不能直接toString; </p><p><strong>注意:[].toString()//‘’ [12].toString()//‘12’ [12,’ASB12’,].toString()//“12,ASB12”</strong></p><p><strong>注意:普通对象.toString()结果”[object Object]” 因为：调用的是自己原型上的toString()，而这个方法是检测数据类型的</strong></p><p><strong>使用 + 号进行字符串拼接</strong></p><h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><blockquote><p>包含：常规数字、NaN</p></blockquote><p><strong>NaN:</strong>  非数字,不是一个数; (但它率属于数字类型)  typeof NaN // “number”  <strong>注意：NaN和任何值（包括自己）都不相等</strong></p><p><strong>isNaN：</strong> 检测一个值是否为非有效数字（数字和数字类型不要弄混淆了，isNaN(NaN) // true ），如果不是有效数字返回true，反之是有效数字返回false；（在使用isNaN进行检测的时候，首先会验证检测的值是否为数字类型，如果不是，先基于**Number()**这个方法，把值转换为数字类型，然后检测）</p><h5 id="把其他类型值转换成数字类型"><a href="#把其他类型值转换成数字类型" class="headerlink" title="把其他类型值转换成数字类型"></a>把其他类型值转换成数字类型</h5><p><strong>Number():</strong> Number(‘11’)//11  Number(‘11A’)//NaN  Number(true)//1  Number(false)//0  Number(null)//0 </p><p><strong>注意：Number(undefined)//NaN undefined代表未定义，未定义代表没有赋值，没有赋值的值它就没有值。没有值的话它就是NaN</strong></p><p><strong>注意：在使用Number() 转换引用类型的时候，是先基于toString()转换成字符串在转换成数字类型</strong><br>例：Number({name:10}) // NaN  {name:10}.toString()//“[object Object]”  Number(“[object Object]”)//NaN<br>Number([]) //0 [].toString()//‘’ Number(‘’)//0<br>Number([12]) //12 [12].toString()//‘12’ Number(‘12’)//12</p><p><strong>parseInt/parseFloat([val],[进制])</strong> 从左到右依次查找有效数字字符，知道遇到非有效数字字符，停止查找</p><p><strong>使用 + 号进行运算：</strong> 如果遇到的值不是数字类型，也需要基于Number()方法转换为数字，在进行运算；</p><h3 id="Number-1"><a href="#Number-1" class="headerlink" title="Number"></a>Number</h3><blockquote><p>只有两个值 true/false</p></blockquote><p><strong>把其它类型值转换成布尔类型</strong></p><blockquote><p>只有0、NaN 、null、’’、undefined 五个值转换为false，其余都转换为true（而且没有任何的特殊情况）</p></blockquote><p><strong>Boolean()</strong></p><p><strong>!/!!</strong></p><p><strong>条件判断</strong></p><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><h4 id="普通对象"><a href="#普通对象" class="headerlink" title="普通对象"></a>普通对象</h4><blockquote><p>{[key]:[value]}<br>注意：对象的属性名一定不能是引用类型，默认会把引用类型只转换成字符串；<br>属性名不存在，获取时值为undefined；属性名为数字，则不能使用.的方式来获取值；属性名不能重复；<br>delete 对象.属性名 (为真删除) 对象.属性名=null (为假删除，属性还在值为空)</p></blockquote><h4 id="数组"><a href="#数组" class="headerlink" title="[] 数组"></a>[] 数组</h4><blockquote><p>[0,1,2]<br>属性名是默认生成的数字，从0开始递增；而且代表每一项的位置<br>有一个天生的属性：length 代表数组长度</p></blockquote><h3 id="function-函数"><a href="#function-函数" class="headerlink" title="function 函数"></a>function 函数</h3><blockquote><p>对一段代码的封装，在需要的时候执行；</p></blockquote><p><strong>创建函数：</strong> 1、function fn(name){….rerun} 2、var fn = function(name){….rerun} 3、(function(name){….rerun})(111) 、~ffunction(){}()</p><blockquote><p>创建函数时，声明形参 例如：name 需要 return 返回值 <strong>有一个参数arguments：函数内置实参集合 是类数组但不能使用数组的方法</strong><br>没有写 return 默认返回值为 undefined<br>函数体中代码遇到 return 不在向下执行 </p></blockquote><p><strong>执行函数：</strong> fn(11) 括号中传递的是实参 1、需要使用形参接收，如未接收则自动丢弃 2、未传递，形参默认值为undefined</p><p><strong>函数执行过程：函数是引用类型，存储在堆中；堆中存储的是函数声明时的字符串，当函数执行时，会开辟一块私有栈内存用来执行函数；所以函数内部的变量不能被外部访问，只能return出去；</strong></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端项目性能优化</title>
      <link href="2020/11/10/qian-duan-xiang-mu-xing-neng-you-hua/"/>
      <url>2020/11/10/qian-duan-xiang-mu-xing-neng-you-hua/</url>
      
        <content type="html"><![CDATA[<h3 id="网络交互层面的优化"><a href="#网络交互层面的优化" class="headerlink" title="网络交互层面的优化"></a>网络交互层面的优化</h3><h4 id="1、DNS预获取"><a href="#1、DNS预获取" class="headerlink" title="1、DNS预获取"></a>1、DNS预获取</h4><p>在我们网站里面可能会存在很多域名，但是每次请求都进行DNS解析时会浪费一定的时间；所以我们可以做一下优化：DNS预获取（在head先获取）</p><p><img src="/img/liulanqi/6.png"></p><h4 id="2、减少HTTP请求次数和请求资源大小"><a href="#2、减少HTTP请求次数和请求资源大小" class="headerlink" title="2、减少HTTP请求次数和请求资源大小"></a>2、减少HTTP请求次数和请求资源大小</h4><ul><li>减少HTTP请求次数：为了避免并发上线而导致的资源延迟加载，页面渲染速度变慢</li><li>文件合并压缩</li><li>图片base64</li><li>尽量使用字体图标</li><li>图片懒加载</li><li>音视频取消预加载</li><li>在客户端和服务器进行信息交互时，对于多项数据尽量基于JSON格式进行传输</li><li>开启服务端的gzip压缩<br>  BASE64的代码很多，不方便开发维护（慎用）：基于webpack的相关加载器-file-loader可以自动把一些图片BASE64</li><li>使用CDN资源</li><li>前端骨架屏：开启只用默认的占位块 占位(保证结构美观)—开始只加载第一屏数据（图片都是延迟加载），滚动到哪一屏幕，再去加载这一屏幕的数据和图片</li><li>服务器骨架屏：首屏内容都是服务器直接渲染好的（在服务器压力能抗住的情况下，比客户端一步步渲染会快一些）例如：SSR</li></ul><h4 id="3、缓存"><a href="#3、缓存" class="headerlink" title="3、缓存"></a>3、缓存</h4><p><img src="/img/xingneng/1.png"></p><p><strong>资源缓存-强缓存和协商缓存</strong><br><img src="/img/xingneng/2.png"><br>    <strong>强缓存</strong><br><img src="/img/xingneng/3.png"><br><img src="/img/xingneng/4.png"><br><img src="/img/xingneng/5.png"><br>    <strong>我们看一下京东是否使用了缓存</strong><br><img src="/img/xingneng/6.png"><br><img src="/img/xingneng/7.png"><br><img src="/img/xingneng/8.png"><br>     <strong>协商缓存</strong><br><img src="/img/xingneng/9.png"><br><img src="/img/xingneng/10.png"><br>    <strong>数据缓存（localStorage ）</strong><br>    <strong>离线缓存 manifest（一般很少用</strong></p><h3 id="网络交互层面的优化-1"><a href="#网络交互层面的优化-1" class="headerlink" title="网络交互层面的优化"></a>网络交互层面的优化</h3><p><img src="/img/xingneng/11.png"></p><h3 id="安全上优化"><a href="#安全上优化" class="headerlink" title="安全上优化"></a>安全上优化</h3><h3 id="webpack优化"><a href="#webpack优化" class="headerlink" title="webpack优化"></a>webpack优化</h3>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器渲染原理</title>
      <link href="2020/10/30/liu-lan-qi-xuan-ran-yuan-li/"/>
      <url>2020/10/30/liu-lan-qi-xuan-ran-yuan-li/</url>
      
        <content type="html"><![CDATA[<p>从一道面试题引起：用户在浏览器地址输入网址到看到页面中间经历了什么？</p><p><img src="/img/liulanqi/1.png"><br>其实中间主要经历了3个阶段：1、HTTP请求阶段 2、HTTP响应阶段 3、浏览器渲染阶段</p><h4 id="进程-Process-和线程-Thread"><a href="#进程-Process-和线程-Thread" class="headerlink" title="进程(Process)和线程(Thread)"></a>进程(Process)和线程(Thread)</h4><p><strong>进程：</strong> <strong>是具有一定独立功能的程序、它是系统进行资源分配和调度的一个独立单位，重点在系统调度和单独的单位，也就是说</strong>进程是可以独立运行的一段程序**。</p><p><strong>线程：</strong> <strong>是进程的一个实体，是CPU调度和分派的基本单位（CPU上真正运行的是线程），程序执行的路径。</strong>。线程自己基本上不拥有系统资源。在运行时，只是暂用一些计数器、寄存器和栈 。</p><p><strong>线程间内存共享：</strong>一个进程的内存空间是共享的，每个线程都可以使用这个共享内存。</p><p><strong>单核CPU执行多任务：</strong>操作系统轮流让各个任务交替执行。例如：任务1执行0.01秒，切换到任务2执行0.01秒，在切换到任务3……由于CPU执行速度过快，我们感知不到感觉像是在同时执行其实不是。</p><p><strong>多核CPU执行多任务：</strong>真正的并行执行多个任务，但是如果任务数量远远多于CPU核心数量，那么操作系统也会自动把多个任务轮流调度到每个核心上执行。</p><p><strong>多线程可以同时执行：</strong>多线程的执行方式和多进程一样，也是由操作系统在多个线程之间快速切换，让每个线程短暂交替运行。</p><h4 id="HTTP请求阶段"><a href="#HTTP请求阶段" class="headerlink" title="HTTP请求阶段"></a>HTTP请求阶段</h4><h5 id="一、URL解析阶段"><a href="#一、URL解析阶段" class="headerlink" title="一、URL解析阶段"></a>一、URL解析阶段</h5><p><strong>URI</strong>：统一资源标识符 （包含URL和URN）；<strong>URL</strong>：统一资源定位符；<strong>URN</strong>：统一资源名称；</p><p><strong>一个完成URL的组成部分和实际意义</strong>（例：<a href="https://www.baidu.com/index.html%EF%BC%89">https://www.baidu.com:443/index.html）</a></p><ul><li><p>协议：传输协议（http：超文本传输协议，传输文本、二进制码、文件流…；https；ftp:资源上传协议，一般应用于吧本地文件直接上传到服务器端）</p></li><li><p>域名</p></li><li><p>端口号（根据端口号，找到当前服务器上的指定服务；0-65535；不同协议有自己默认端口：http–》80、https–》443、ftp–》21）</p></li><li><p>请求资源和路径名称（/stu/index.html ：一般情况，我们访问的是inde.html是可以省略不写的）</p></li><li><p>？号传参部分 (?xxx=xxx)</p><p>如遇需要进行编码处理方法：</p><p>1、encodeURL / decodeURL (只能把中文和空格编译成编码,一般用来把整个url进行编码)</p><p>2、encodeURLComponent / decodeURLComponent (所有特殊字符都会进行编码，一般不会用来处理整个url,只给传递的参数值进行特殊处理)<br>以上两种客户端和服务器端都支持</p><p>3、escape / unescape (这种方式不一定所有服务器端都支持)</p><p>…</p></li><li><p>哈希 (#xxx)</p><blockquote><p><strong>伪URL</strong></p><p>什么地方会使用伪url？</p><p>1、SEO优化</p><p>2、数据请求的接口地址</p><p>动态页面地址：真实地址</p><p><a href="https://item.jd.com/detail.php?id=22298647726">https://item.jd.com/detail.php?id=22298647726</a></p><p>需要把上面的地址重写为下面的静态地址需要用到：<strong>URL伪重写技术</strong></p><p><a href="https://item.jd.com/22298647726.html">https://item.jd.com/22298647726.html</a></p></blockquote></li></ul><h5 id="二、DNS域名解析"><a href="#二、DNS域名解析" class="headerlink" title="二、DNS域名解析"></a>二、DNS域名解析</h5><p>DNS域名解析是什么？</p><p>通过域名找到对应的服务器外网IP；</p><p>网站，每发送一个TCP请求，都要进行DNS解析（一旦解析过一次，浏览器一般会缓存解析记录，缓存时间一般在1分钟左右）</p><p>DNS解析时访问服务器的顺序：<br><img src="/img/liulanqi/2.png"></p><p>优化手段：DNS预获取<br><img src="/img/liulanqi/3.png"></p><h5 id="三、建立TCP连接（三次握手）"><a href="#三、建立TCP连接（三次握手）" class="headerlink" title="三、建立TCP连接（三次握手）"></a>三、建立TCP连接（三次握手）</h5><p>基于TCP的三次握手，能够建立客户端和服务器的连接通道，只有建立好通道，才能基于HTTP等传输协议，实现客户端和服务器端的信息交互<br><img src="/img/liulanqi/4.png"></p><h5 id="四、发送HTTP请求"><a href="#四、发送HTTP请求" class="headerlink" title="四、发送HTTP请求"></a>四、发送HTTP请求</h5><p>基于HTTP等传输协议，客户端把一些信息传输给服务器</p><ul><li><p>HTTP请求报文（所有客户端传输给服务器的内容，统称请求报文）</p><p>包含：请求起始行、请求头、请求主体</p></li><li><p>强缓存 和 协商缓存 （主要作用是性能优化，减少http请求次数）具体详解，看性能优化文章</p></li></ul><h4 id="HTTP响应阶段"><a href="#HTTP响应阶段" class="headerlink" title="HTTP响应阶段"></a>HTTP响应阶段</h4><h5 id="一、服务器接收请求，并进行处理，最后把信息返回给客户端"><a href="#一、服务器接收请求，并进行处理，最后把信息返回给客户端" class="headerlink" title="一、服务器接收请求，并进行处理，最后把信息返回给客户端"></a>一、服务器接收请求，并进行处理，最后把信息返回给客户端</h5><ul><li>HTTP响应报文 （服务器返回给客户端的内容）<br>包含：响应起始行、响应头、响应主体</li></ul><h5 id="二、断开TCP连接通道（四次挥手）"><a href="#二、断开TCP连接通道（四次挥手）" class="headerlink" title="二、断开TCP连接通道（四次挥手）"></a>二、断开TCP连接通道（四次挥手）</h5><p>** 当客户端把请求放给服务器后，就挥第一次手**<br><img src="/img/liulanqi/5.png"></p><p>优化点：服务端设置 Connection:Keep-Alive 保持TCP不中断</p><h4 id="浏览器渲染阶段"><a href="#浏览器渲染阶段" class="headerlink" title="浏览器渲染阶段"></a>浏览器渲染阶段</h4><p>浏览器是多线程的，页面渲染是单线的；</p><h5 id="一、拿到index-html后浏览器会开辟一块栈内存，同时分配一个主线程“自上而下，自左而右”的去解析执行；"><a href="#一、拿到index-html后浏览器会开辟一块栈内存，同时分配一个主线程“自上而下，自左而右”的去解析执行；" class="headerlink" title="一、拿到index.html后浏览器会开辟一块栈内存，同时分配一个主线程“自上而下，自左而右”的去解析执行；"></a>一、拿到index.html后浏览器会开辟一块栈内存，同时分配一个主线程“自上而下，自左而右”的去解析执行；</h5><h5 id="二、在解析执行DOM结构时遇到link、img、video…浏览器会开启一个全新线程去加载资源，但不会执行。主线程继续向下执行；"><a href="#二、在解析执行DOM结构时遇到link、img、video…浏览器会开启一个全新线程去加载资源，但不会执行。主线程继续向下执行；" class="headerlink" title="二、在解析执行DOM结构时遇到link、img、video…浏览器会开启一个全新线程去加载资源，但不会执行。主线程继续向下执行；"></a>二、在解析执行DOM结构时遇到<strong>link</strong>、<strong>img</strong>、<strong>video</strong>…浏览器会开启一个全新线程去加载资源，但不会执行。主线程继续向下执行；</h5><ul><li>遇到 <strong>style</strong> 内嵌样式正常解析执行</li><li>@import 导入样式 （同步）不会开辟新线程去加载资源，而是主线程去获取资源并加载完毕才会继续向下继续解析执行DOM </li></ul><h5 id="三、遇到script、外链js会去获取资源并执行，会阻塞DOM生成；优化：使用defer、async去异步获取资源，等dom渲染完执行；"><a href="#三、遇到script、外链js会去获取资源并执行，会阻塞DOM生成；优化：使用defer、async去异步获取资源，等dom渲染完执行；" class="headerlink" title="三、遇到script、外链js会去获取资源并执行，会阻塞DOM生成；优化：使用defer、async去异步获取资源，等dom渲染完执行；"></a>三、遇到<strong>script</strong>、外链js会去获取资源并<strong>执行</strong>，会阻塞DOM生成；优化：使用<strong>defer</strong>、<strong>async</strong>去异步获取资源，等dom渲染完执行；</h5><ul><li>现代浏览器都有完善的代码扫描机制，如果遇到script需要同步加载执行时，同时会向下扫描代码，如果发现有一些异步获取资源代码，此时就开始请求资源了</li><li>自我等待机制：因为在JS中可能会有操作元素样式的情况出现，所以哪怕异步请求的js资源加载完成了，执行js代码也会等到css加载并渲染完成后才会执行</li><li>defer 异步获取资源后，按照顺序去执行</li><li>async 异步获取资源后，执行是无序的，谁先加载回来谁先执行</li><li>DOMContentLoaded() : 当DOM结构加载完成就会触发</li><li>$(function(){})||$(doucment).ready(function(){})</li><li>load() : 所有资源加载完成才会执行，包含图片等资源加载</li></ul><h5 id="四、自上而下执行完毕后，会生成DOM-Tree"><a href="#四、自上而下执行完毕后，会生成DOM-Tree" class="headerlink" title="四、自上而下执行完毕后，会生成DOM Tree"></a>四、自上而下执行完毕后，会生成<strong>DOM Tree</strong></h5><h5 id="五、主线程现在可以去执行加载回来的css资源了，执行完css会生成CSSOM"><a href="#五、主线程现在可以去执行加载回来的css资源了，执行完css会生成CSSOM" class="headerlink" title="五、主线程现在可以去执行加载回来的css资源了，执行完css会生成CSSOM"></a>五、主线程现在可以去执行加载回来的css资源了，执行完css会生成<strong>CSSOM</strong></h5><h5 id="六、将DOM-Tree和CSSOM结合生成Render-Tree-渲染树"><a href="#六、将DOM-Tree和CSSOM结合生成Render-Tree-渲染树" class="headerlink" title="六、将DOM Tree和CSSOM结合生成Render Tree(渲染树)"></a>六、将<strong>DOM Tree</strong>和<strong>CSSOM</strong>结合生成<strong>Render Tree</strong>(渲染树)</h5><h5 id="六、浏览器通知GPU-显卡-开始按照Render-Tree绘制图形到页面中"><a href="#六、浏览器通知GPU-显卡-开始按照Render-Tree绘制图形到页面中" class="headerlink" title="六、浏览器通知GPU(显卡)开始按照Render Tree绘制图形到页面中"></a>六、浏览器通知GPU(显卡)开始按照Render Tree绘制图形到页面中</h5><p><img src="/img/liulanqi/6.png"></p><h4 id="DOM的重绘和回流"><a href="#DOM的重绘和回流" class="headerlink" title="DOM的重绘和回流"></a>DOM的重绘和回流</h4><p><strong>重绘</strong>：元素样式的改变（但宽高、大小、位置等不变）</p><p><strong>回流</strong>：元素的大小或者位置发生了变化，触发重新布局导致渲染树重新计算布局和渲染</p><p><strong>重绘不一定回流，回流一定触发重绘</strong></p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器渲染原理 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
